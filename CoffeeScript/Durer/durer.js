// Generated by CoffeeScript 1.6.3
(function() {
  var FillShape, GlyphFunctions, OutlineDrawer, Point, SvgPathGenerator, Util, bindValueToText, changeProofSize, changeProportions, changeSampleText, drawProofs, drawSampleText, getLetterShape, intersect, intersectCircles, midPoint, onEvent, onload, partWay, proportions, redrawProofs, showProofsChanged, showSampleChanged, sys, vertCircle;

  showProofsChanged = function() {
    var checkbox, proofs;
    checkbox = document.getElementById("showProofs");
    proofs = document.getElementById("proofs");
    if (checkbox.checked) {
      proofs.style.display = "block";
    } else {
      proofs.style.display = "none";
    }
  };

  showSampleChanged = function() {
    var checkbox, sample;
    checkbox = document.getElementById('showSample');
    sample = document.getElementById('sample');
    if (checkbox.checked) {
      sample.style.display = 'block';
    } else {
      sample.style.display = 'none';
    }
  };

  redrawProofs = function() {
    sys.showOutlines = document.getElementById('showOutlines').checked;
    sys.overshoot = document.getElementById('overshoot').checked;
    sys.fillGlyph = document.getElementById('fillGlyph').checked;
    sys.glyphColor = document.getElementById('glyphColor').value;
    sys.strokeGlyph = document.getElementById('strokeGlyph').checked;
    drawProofs();
  };

  changeProofSize = function() {
    var canvasRule, sheet, size, wideCanvasRule;
    size = (document.getElementById('proofSize')).value | 0;
    sheet = document.styleSheets[0];
    if (sheet.cssRules != null) {
      canvasRule = sheet.cssRules[1];
      wideCanvasRule = sheet.cssRules[2];
    } else if (sheet.rules != null) {
      canvasRule = sheet.rules[1];
      wideCanvasRule = sheet.rules[2];
    } else {
      console.log('cannot change stylesheet');
      return;
    }
    canvasRule.style.width = size + 'px';
    canvasRule.style.height = size + 'px';
    wideCanvasRule.style.width = (2 * size) + 'px';
  };

  changeProportions = function() {
    proportions.readFromDocument();
    drawProofs();
    drawSampleText();
  };

  changeSampleText = function() {
    drawSampleText();
  };

  sys = {
    canvas: null,
    ctx: null,
    width: 0,
    height: 0,
    x_margin: 0,
    y_margin: 0,
    working_width: 0,
    working_height: 0,
    overshoot: true,
    showOutlines: true,
    fillGlyph: true,
    strokeGlyph: false,
    glyphColor: 'black'
  };

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
      this.isCanvas = false;
    }

    Point.prototype.toCanvas = function() {
      var cpt, cx, cy;
      if (this.isCanvas) {
        throw 'Already a canvas point';
      }
      cx = this.x * sys.working_width + sys.x_margin;
      cy = this.y * sys.working_height + sys.y_margin;
      cpt = new Point(cx, cy);
      cpt.isCanvas = true;
      return cpt;
    };

    Point.prototype.fromCanvas = function() {
      var ax, ay;
      if (!this.isCanvas) {
        throw 'This is not a canvas point';
      }
      ax = (this.x - sys.x_margin) / sys.working_width;
      ay = (this.y - sys.y_margin) / sys.working_height;
      return new Point(ax, ay);
    };

    Point.prototype.towards = function(other, dist) {
      var dx, dy, len;
      dx = other.x - this.x;
      dy = other.y - this.y;
      len = Math.sqrt(dx * dx + dy * dy);
      return new Point(this.x + (dx * dist) / len, this.y + (dy * dist) / len);
    };

    Point.prototype.distance = function(other) {
      var dx, dy;
      dx = this.x - other.x;
      dy = this.y - other.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    return Point;

  })();

  intersect = function(a, b, c, d) {
    var ac, cc, slope_a, slope_c, x, y;
    slope_a = a.x !== b.x ? (b.y - a.y) / (b.x - a.x) : 'vertical';
    slope_c = c.x !== d.x ? (d.y - c.y) / (d.x - c.x) : 'vertical';
    if (slope_a === slope_c) {
      return void 0;
    } else if (slope_a === 'vertical') {
      return new Point(a.x, slope_c * (a.x - c.x) + c.y);
    } else if (slope_c === 'vertical') {
      return new Point(c.x, slope_a * (c.x - a.x) + a.y);
    }
    ac = a.y - slope_a * a.x;
    cc = c.y - slope_c * c.x;
    x = (cc - ac) / (slope_a - slope_c);
    y = slope_a * x + ac;
    return new Point(x, y);
  };

  vertCircle = function(c, r, x) {
    var dx, dy;
    dx = x - c.x;
    if (Math.abs(dx) > r) {
      return void 0;
    }
    dy = Math.sqrt(r * r - dx * dx);
    return {
      upper: new Point(x, c.y - dy),
      lower: new Point(x, c.y + dy)
    };
  };

  intersectCircles = function(ac, ar, bc, br) {
    var a, d, d1, dir, dx, dy, pd;
    d = ac.distance(bc);
    d1 = (d * d - br * br + ar * ar) / (2 * d);
    a = Math.sqrt(ar * ar - d1 * d1);
    pd = ac.towards(bc, d1);
    dx = pd.x - ac.x;
    dy = pd.y - ac.y;
    dir = new Point(pd.x + dy, pd.y - dx);
    return {
      left: pd.towards(dir, a),
      right: pd.towards(dir, -a)
    };
  };

  partWay = function(left, right, prop) {
    var iprop;
    iprop = 1 - prop;
    return new Point(left.x * iprop + right.x * prop, left.y * iprop + right.y * prop);
  };

  midPoint = function(left, right) {
    return new Point((left.x + right.x) / 2, (left.y + right.y) / 2);
  };

  OutlineDrawer = (function() {
    function OutlineDrawer(context) {
      this.context = context;
    }

    OutlineDrawer.prototype.drawBezier = function(from, cp1, cp2, to) {
      if (!sys.showOutlines) {
        return;
      }
      this.context.beginPath();
      this.context.moveTo(from.x, from.y);
      this.context.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, to.x, to.y);
      return this.context.stroke();
    };

    OutlineDrawer.prototype.drawLine = function(from, to) {
      var fpt, tpt;
      if (!sys.showOutlines) {
        return;
      }
      if (sys.overshoot) {
        fpt = partWay(from, to, -0.1).toCanvas();
        tpt = partWay(to, from, -0.1).toCanvas();
      } else {
        fpt = from.toCanvas();
        tpt = to.toCanvas();
      }
      this.context.beginPath();
      this.context.moveTo(fpt.x, fpt.y);
      this.context.lineTo(tpt.x, tpt.y);
      return this.context.stroke();
    };

    OutlineDrawer.prototype.drawCircle = function(c, p) {
      var radius;
      if (!sys.showOutlines) {
        return;
      }
      c = c.toCanvas();
      p = p.toCanvas();
      radius = c.distance(p);
      this.context.beginPath();
      this.context.arc(c.x, c.y, radius, 0, Math.PI * 2, true);
      return this.context.stroke();
    };

    OutlineDrawer.prototype.drawTouchingCircle = function(a, b, c) {
      var adx, ady, cc, cdx, cdy, dab, dac;
      dab = a.distance(b);
      dac = b.distance(c);
      if (dab < dac) {
        c = b.towards(c, dab);
      } else {
        a = b.towards(a, dac);
      }
      adx = a.x - b.x;
      ady = a.y - b.y;
      cdx = c.x - b.x;
      cdy = c.y - b.y;
      cc = intersect(a, new Point(a.x - ady, a.y + adx), c, new Point(c.x + cdy, c.y - cdx));
      this.drawLine(c, cc);
      this.drawLine(a, cc);
      this.drawCircle(cc, a);
      return {
        from: a,
        to: c,
        center: cc
      };
    };

    OutlineDrawer.prototype.labelPoints = function(named_points) {
      var c, lr, n, pt, ptc, v;
      if (!sys.showOutlines) {
        return;
      }
      this.context.font = '15px Times New Roman';
      this.context.textAlign = 'center';
      this.context.textBaseline = 'middle';
      this.context.fillStyle = 'black';
      c = new Point(0.5, 0.5).toCanvas();
      lr = new Point(1, 1).toCanvas();
      for (n in named_points) {
        v = named_points[n];
        pt = v.toCanvas();
        if (10 >= c.distance(pt)) {
          ptc = pt.towards(lr, -10);
        } else {
          ptc = pt.towards(c, -10);
        }
        this.context.fillText(n, ptc.x, ptc.y);
      }
    };

    return OutlineDrawer;

  })();

  SvgPathGenerator = (function() {
    var pi_by_two, two_pi;

    function SvgPathGenerator() {
      var i, _i, _ref;
      this.path = '';
      this.hasLimits = false;
      this.kernBlocks = 5;
      this.leftLimits = [];
      this.rightLimits = [];
      for (i = _i = 0, _ref = this.kernBlocks; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.leftLimits[i] = 1;
        this.rightLimits[i] = 0;
      }
    }

    SvgPathGenerator.prototype.append = function(item) {
      if (this.path !== '') {
        this.path += ' ';
      }
      this.path += item;
    };

    SvgPathGenerator.prototype.computeKernLimits = function(x, y) {
      var ax, ay, c_x, c_y, cx, cy, i, m, t_x, t_y, _i, _ref;
      if (this.last_y < y) {
        ax = this.last_x;
        ay = this.last_y;
        cx = x;
        cy = y;
      } else {
        ax = x;
        ay = y;
        cx = this.last_x;
        cy = this.last_y;
      }
      m = ax !== cx ? (cy - ay) / (cx - ax) : 'vertical';
      c_y = 0;
      for (i = _i = 0, _ref = this.kernBlocks; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        t_y = c_y;
        c_y = (i + 1) / this.kernBlocks;
        if ((ay > c_y) || (cy < t_y)) {
          continue;
        }
        if (m === 'vertical') {
          c_x = t_x = ax;
        } else if (m === 0) {
          if (ay >= t_y && ay <= c_y) {
            this.leftLimits[i] = Math.min(this.leftLimits[i], ax, cx);
            this.rightLimits[i] = Math.max(this.rightLimits[i], ax, cx);
            return;
          }
          continue;
        } else {
          t_x = ax + (t_y - ay) / m;
          c_x = ax + (c_y - ay) / m;
        }
        if (ay > t_y) {
          t_x = ax;
        }
        if (cy < c_y) {
          c_x = cx;
        }
        this.leftLimits[i] = Math.min(this.leftLimits[i], t_x, c_x);
        this.rightLimits[i] = Math.max(this.rightLimits[i], t_x, c_x);
      }
    };

    SvgPathGenerator.prototype.extendLimits = function(x, y) {
      if (!this.hasLimits) {
        this.lx = this.rx = x;
        this.ty = this.by = y;
        this.hasLimits = true;
      } else {
        if (x < this.lx) {
          this.lx = x;
        } else if (x > this.rx) {
          this.rx = x;
        }
        if (y < this.ty) {
          this.ty = y;
        } else if (y > this.by) {
          this.by = y;
        }
      }
      this.computeKernLimits(x, y);
      this.last_x = x;
      this.last_y = y;
    };

    SvgPathGenerator.prototype.beginPath = function() {
      this.path = '';
      this.hasLimits = false;
    };

    SvgPathGenerator.prototype.moveTo = function(x, y) {
      this.last_x = x;
      this.last_y = y;
      this.append('M ' + x + ' ' + y);
    };

    SvgPathGenerator.prototype.lineTo = function(x, y) {
      this.extendLimits(x, y);
      this.append('L ' + x + ' ' + y);
    };

    two_pi = Math.PI * 2;

    pi_by_two = Math.PI / 2;

    SvgPathGenerator.prototype.clampAngle = function(a) {
      a = parseFloat(a);
      while (a < 0) {
        a += two_pi;
      }
      while (a >= two_pi) {
        a -= two_pi;
      }
      return a;
    };

    SvgPathGenerator.prototype.arc = function(cx, cy, radius, from, to, forwards) {
      var cfr, cpf, ctr, ex, ey, f, partial, sfr, str, sx, sy;
      from = this.clampAngle(from);
      to = this.clampAngle(to);
      if (forwards) {
        while (to > from) {
          to -= two_pi;
        }
      } else {
        while (to < from) {
          to += two_pi;
        }
      }
      ctr = Math.cos(from);
      str = Math.sin(from);
      ex = cx + radius * ctr;
      ey = cy + radius * str;
      f = 0.551784 * radius;
      this.lineTo(ex, ey);
      while ((forwards && (to < from)) || (!forwards && (to > from))) {
        if (Math.abs(to - from) > pi_by_two) {
          partial = forwards ? from - pi_by_two : from + pi_by_two;
        } else {
          partial = to;
        }
        cfr = ctr;
        sfr = str;
        sx = ex;
        sy = ey;
        ctr = Math.cos(partial);
        str = Math.sin(partial);
        ex = cx + radius * ctr;
        ey = cy + radius * str;
        cpf = f * (partial - from) / pi_by_two;
        this.bezierCurveTo(sx - cpf * sfr, sy + cpf * cfr, ex + cpf * str, ey - cpf * ctr, ex, ey);
        from = partial;
      }
    };

    SvgPathGenerator.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, tx, ty) {
      this.extendLimits(cp1x, cp1y);
      this.extendLimits(cp2x, cp2y);
      this.extendLimits(tx, ty);
      this.append('C ' + cp1x + ' ' + cp1y + ' ' + cp2x + ' ' + cp2y + ' ' + tx + ' ' + ty);
    };

    SvgPathGenerator.prototype.closePath = function() {
      this.append('Z');
    };

    SvgPathGenerator.prototype.fill = function() {};

    SvgPathGenerator.prototype.stroke = function() {};

    return SvgPathGenerator;

  })();

  FillShape = (function() {
    function FillShape(context) {
      this.context = context;
      this.context.beginPath();
    }

    FillShape.prototype.moveTo = function(p) {
      p = p.toCanvas();
      this.context.moveTo(p.x, p.y);
    };

    FillShape.prototype.lineTo = function(p) {
      p = p.toCanvas();
      this.context.lineTo(p.x, p.y);
    };

    FillShape.prototype.addArc = function(a, forwards) {
      var center, end, from, radius, start, to;
      from = a.from.toCanvas();
      to = a.to.toCanvas();
      center = a.center.toCanvas();
      radius = center.distance(from);
      start = Math.atan2(from.y - center.y, from.x - center.x);
      end = Math.atan2(to.y - center.y, to.x - center.x);
      this.context.arc(center.x, center.y, radius, start, end, forwards);
    };

    FillShape.prototype.addBezier = function(cp1, cp2, to) {
      cp1 = cp1.toCanvas();
      cp2 = cp2.toCanvas();
      to = to.toCanvas();
      this.context.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, to.x, to.y);
    };

    FillShape.prototype.closeAndFill = function() {
      this.context.closePath();
      if (sys.fillGlyph) {
        this.context.fillStyle = sys.glyphColor;
        this.context.fill();
      }
      if (sys.strokeGlyph) {
        if (sys.fillGlyph && sys.glyphColor === 'white') {
          this.context.strokeStyle = 'black';
        } else {
          this.context.strokeStyle = sys.glyphColor;
        }
        this.context.lineWidth = 1;
        this.context.stroke();
      }
    };

    return FillShape;

  })();

  Util = {
    initializeCanvas: function(id) {
      if (id === void 0) {
        sys.ctx = new SvgPathGenerator();
        sys.width = 1;
        sys.height = 1;
        sys.x_margin = 0;
        sys.y_margin = 0;
        sys.working_width = 1;
        sys.working_height = 1;
        return;
      }
      sys.canvas = document.getElementById(id);
      sys.ctx = sys.canvas.getContext('2d');
      sys.ctx.lineWidth = 0.25;
      sys.ctx.strokeStyle = 'black';
      sys.ctx.fillStyle = 'black';
      sys.width = sys.canvas.width;
      sys.height = sys.canvas.height;
      sys.ctx.clearRect(0, 0, sys.width, sys.height);
      if (sys.width > sys.height) {
        sys.width = sys.height;
      } else {
        sys.height = sys.width;
      }
      sys.x_margin = sys.width * 0.1;
      sys.y_margin = sys.height * 0.1;
      sys.working_width = sys.width - 2 * sys.x_margin;
      sys.working_height = sys.height - 2 * sys.y_margin;
    },
    initializeSquare: function(named_points, aspect) {
      var bottom, left, right, top;
      if (aspect <= 1) {
        top = 0;
        bottom = 1;
        left = 0.5 - aspect / 2;
        right = 0.5 + aspect / 2;
      } else {
        left = 0;
        right = 1;
        top = 1 - 1 / aspect;
        bottom = 1;
      }
      named_points.a = new Point(left, top);
      named_points.b = new Point(right, top);
      named_points.c = new Point(left, bottom);
      named_points.d = new Point(right, bottom);
      return right - left;
    }
  };

  GlyphFunctions = {
    initializeGlyph: function(id, proportions) {
      var prop;
      Util.initializeCanvas(id);
      this.labels = {};
      prop = Util.initializeSquare(this.labels, proportions.aspect);
      this.wide = proportions.broad_stem * prop;
      this.serif = proportions.serif * prop;
      this.narrow = proportions.narrow_stem * this.wide;
    },
    drawA: function(id, variant, proportions) {
      var dx, dy, eleft, eright, ert, esl, gdown, hdown, iright, isl, isr, kleft, ksl, ksr, outline, render, tcc, tcct;
      if (variant !== 'b' && variant !== 'c') {
        variant = 'a';
      }
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.b);
      this.labels.f = midPoint(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      this.labels.g = midPoint(this.labels.a, this.labels.c);
      this.labels.h = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.g, this.labels.h);
      this.labels.i = this.labels.c.towards(this.labels.d, this.serif);
      this.labels.k = this.labels.d.towards(this.labels.c, this.serif);
      eleft = this.labels.e.towards(this.labels.a, this.narrow);
      eright = eleft.towards(this.labels.b, this.wide);
      if (variant === 'b') {
        eleft = this.labels.e.towards(this.labels.a, this.wide);
        eright = this.labels.e.towards(this.labels.b, this.narrow);
      }
      if (variant === 'a') {
        outline.drawLine(this.labels.i, eleft);
        outline.drawLine(this.labels.k, eright);
      } else if (variant === 'b') {
        outline.drawLine(this.labels.i, this.labels.e);
        outline.drawLine(this.labels.e, this.labels.k);
      } else if (variant === 'c') {
        outline.drawLine(this.labels.i, eleft);
        outline.drawLine(this.labels.k, eright);
      }
      iright = this.labels.i.towards(this.labels.d, this.narrow);
      kleft = this.labels.k.towards(this.labels.c, this.wide);
      if (variant === 'a') {
        outline.drawLine(iright, this.labels.e);
        outline.drawLine(kleft, eleft);
      } else if (variant === 'b') {
        outline.drawLine(iright, eright);
        outline.drawLine(eleft, kleft);
      } else if (variant === 'c') {
        outline.drawLine(iright, this.labels.e);
        outline.drawLine(kleft, eleft);
      }
      gdown = this.labels.g.towards(this.labels.c, this.narrow);
      hdown = this.labels.h.towards(this.labels.d, this.narrow);
      outline.drawLine(gdown, hdown);
      isl = outline.drawTouchingCircle(this.labels.c, this.labels.i, eleft);
      isr = outline.drawTouchingCircle(this.labels.e, iright, iright.towards(this.labels.d, this.serif));
      ksr = outline.drawTouchingCircle(eright, this.labels.k, this.labels.d);
      ksl = outline.drawTouchingCircle(kleft.towards(this.labels.c, this.serif), kleft, eleft);
      if (variant === 'a') {
        ert = eright.towards(this.labels.k, this.serif / 2);
        outline.drawLine(eright, ert);
        dx = ert.x - eright.x;
        dy = ert.y - eright.y;
        tcc = new Point(eright.x + dy, eright.y - dx);
        outline.drawLine(eright, tcc);
        outline.drawCircle(tcc, eright);
        tcct = new Point(tcc.x - dx, tcc.y - dy);
        outline.drawLine(tcc, tcct);
        outline.drawBezier(tcct, tcct.towards(this.labels.a, this.serif / 2), eleft.towards(this.labels.k, this.serif / 2), eleft);
      } else if (variant === 'c') {
        esl = outline.drawTouchingCircle(this.labels.i, eleft, eleft.towards(this.labels.a, this.serif));
      }
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(isl, true);
      if (variant === 'a') {
        render.lineTo(eleft);
        render.addBezier(eleft.towards(this.labels.k, this.serif / 2), tcct.towards(this.labels.a, this.serif / 2), tcct);
        render.addArc({
          from: tcct,
          to: eright,
          center: tcc
        }, true);
      } else if (variant === 'b') {
        render.lineTo(this.labels.e);
      } else if (variant === 'c') {
        render.lineTo(esl.from);
        render.addArc(esl, true);
        render.lineTo(eright);
      }
      render.lineTo(ksr.from);
      render.addArc(ksr, true);
      render.lineTo(kleft);
      render.addArc(ksl, true);
      render.lineTo(intersect(kleft, eleft, gdown, hdown));
      if (variant === 'a' || variant === 'c') {
        render.lineTo(intersect(iright, this.labels.e, gdown, hdown));
      } else if (variant === 'b') {
        render.lineTo(intersect(iright, eright, gdown, hdown));
      }
      render.lineTo(isr.from);
      render.addArc(isr, true);
      render.lineTo(this.labels.c);
      if (variant === 'a' || variant === 'c') {
        render.moveTo(intersect(this.labels.g, this.labels.h, iright, this.labels.e));
        render.lineTo(intersect(kleft, eleft, this.labels.g, this.labels.h));
        render.lineTo(intersect(iright, this.labels.e, kleft, eleft));
      } else if (variant === 'b') {
        render.moveTo(intersect(this.labels.g, this.labels.h, iright, eright));
        render.lineTo(intersect(kleft, eleft, this.labels.g, this.labels.h));
        render.lineTo(intersect(iright, eright, kleft, eleft));
      }
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawB: function(id, variant, proportions) {
      var bl_l, bl_r, bls, brs, icc, icc_l, icr, lic, lir, ll_bl, ll_br, ll_brr, ll_tl, ll_tr, loc, lor, lr_c, lr_lc, lr_tl, ml_l, ml_r, nb, nt, outline, pp, render, tir, tl, tl_l, tl_r, tls, toc, tor, tu;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      this.labels.g = midPoint(this.labels.a, this.labels.e);
      this.labels.h = midPoint(this.labels.b, this.labels.f);
      outline.drawLine(this.labels.g, this.labels.h);
      ll_tl = this.labels.a.towards(this.labels.b, this.serif);
      ll_tr = ll_tl.towards(this.labels.b, this.wide);
      ll_bl = this.labels.c.towards(this.labels.d, this.serif);
      ll_br = ll_bl.towards(this.labels.d, this.wide);
      outline.drawLine(ll_tl, ll_bl);
      outline.drawLine(ll_tr, ll_br);
      tls = outline.drawTouchingCircle(ll_bl, ll_tl, this.labels.a);
      bls = outline.drawTouchingCircle(this.labels.c, ll_bl, ll_tl);
      this.labels.i = ll_tr.towards(this.labels.b, this.wide);
      this.labels.k = ll_br.towards(this.labels.d, this.wide);
      outline.drawLine(this.labels.i, this.labels.k);
      this.labels.l = intersect(this.labels.g, this.labels.h, this.labels.i, this.labels.k);
      tl_l = this.labels.a.towards(this.labels.c, this.narrow);
      tl_r = this.labels.i.towards(this.labels.k, this.narrow);
      outline.drawLine(tl_l, tl_r);
      ml_l = this.labels.e.towards(this.labels.a, this.narrow);
      ml_r = (intersect(this.labels.e, this.labels.f, this.labels.i, this.labels.k)).towards(this.labels.i, this.narrow);
      this.labels.m = ml_r;
      outline.drawLine(ml_l, ml_r);
      outline.drawCircle(this.labels.l, ml_r);
      tir = this.labels.l.distance(ml_r);
      this.labels.n = this.labels.l.towards(this.labels.h, tir + this.wide);
      tor = this.labels.l.distance(this.labels.i);
      toc = this.labels.n.towards(this.labels.g, tor);
      outline.drawCircle(toc, this.labels.n);
      if (variant === 'p') {
        ll_brr = ll_br.towards(this.labels.d, this.serif);
        brs = outline.drawTouchingCircle(ll_tr, ll_br, ll_brr);
      } else if (variant === 'r') {
        ll_brr = ll_br.towards(this.labels.d, this.serif);
        brs = outline.drawTouchingCircle(ll_tr, ll_br, ll_brr);
        this.labels.q = midPoint(this.labels.a, this.labels.b);
        this.labels.r = midPoint(this.labels.c, this.labels.d);
        outline.drawLine(this.labels.q, this.labels.r);
        this.labels.s = (vertCircle(toc, tor, this.labels.q.x)).lower;
        lr_c = this.labels.d.towards(this.labels.c, this.serif);
        outline.drawLine(this.labels.s, lr_c);
        lr_lc = lr_c.towards(this.labels.c, this.wide);
        lr_tl = (intersect(this.labels.e, this.labels.f, this.labels.s, lr_c)).towards(this.labels.e, this.wide);
        outline.drawLine(lr_tl, lr_lc);
        tu = outline.drawTouchingCircle(this.labels.s, lr_c, this.labels.d);
        tl = outline.drawTouchingCircle(this.labels.d, lr_lc, lr_tl);
      } else {
        nt = new Point(this.labels.n.x, this.labels.a.y);
        nb = new Point(this.labels.n.x, this.labels.c.y);
        outline.drawLine(nt, nb);
        this.labels.o = midPoint(ml_l, this.labels.c);
        this.labels.p = new Point(this.labels.d.x, this.labels.o.y);
        outline.drawLine(this.labels.o, this.labels.p);
        bl_l = this.labels.c.towards(this.labels.a, this.narrow);
        bl_r = nb.towards(nt, this.narrow);
        outline.drawLine(bl_l, bl_r);
        this.labels.q = intersect(this.labels.i, this.labels.k, bl_l, bl_r);
        this.labels.r = intersect(this.labels.o, this.labels.p, nt, nb);
        lir = this.labels.o.distance(this.labels.e);
        lic = this.labels.r.towards(this.labels.o, lir);
        outline.drawCircle(lic, this.labels.r);
        this.labels.s = this.labels.r.towards(this.labels.p, this.wide);
        lor = this.labels.o.distance(this.labels.c);
        loc = this.labels.s.towards(this.labels.o, lor);
        outline.drawCircle(loc, this.labels.s);
        icr = this.wide * 2 / 3;
        icc_l = bl_l.towards(bl_r, this.serif + this.wide + icr);
        icc = outline.drawTouchingCircle(ll_tr, intersect(bl_l, bl_r, ll_tr, ll_br), icc_l);
      }
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(bls, true);
      render.addArc(tls, true);
      if (variant === 'p') {
        render.addArc({
          from: new Point(toc.x, toc.y - tor),
          to: new Point(toc.x, toc.y + tor),
          center: toc
        }, false);
        render.lineTo(intersect(this.labels.e, this.labels.f, ll_tr, ll_br));
        render.addArc(brs, true);
        render.lineTo(this.labels.c);
        render.moveTo(intersect(tl_l, tl_r, ll_tr, ll_br));
        render.lineTo(intersect(ml_l, ml_r, ll_tr, ll_br));
        render.addArc({
          from: ml_r,
          to: tl_r,
          center: this.labels.l
        }, true);
      } else if (variant === 'r') {
        render.addArc({
          from: new Point(toc.x, toc.y - tor),
          to: this.labels.s,
          center: toc
        }, false);
        render.addArc(tu, true);
        render.addArc(tl, false);
        render.lineTo(lr_tl);
        render.lineTo(intersect(this.labels.e, this.labels.f, ll_tr, ll_br));
        render.addArc(brs, true);
        render.lineTo(this.labels.c);
        render.moveTo(intersect(tl_l, tl_r, ll_tr, ll_br));
        render.lineTo(intersect(ml_l, ml_r, ll_tr, ll_br));
        render.addArc({
          from: ml_r,
          to: tl_r,
          center: this.labels.l
        }, true);
      } else {
        pp = (intersectCircles(toc, tor, loc, lor)).left;
        render.addArc({
          from: new Point(toc.x, toc.y - tor),
          to: pp,
          center: toc
        }, false);
        render.addArc({
          from: pp,
          to: new Point(loc.x, loc.y + lor),
          center: loc
        }, false);
        render.lineTo(this.labels.c);
        render.moveTo(intersect(tl_l, tl_r, ll_tr, ll_br));
        render.lineTo(intersect(ml_l, ml_r, ll_tr, ll_br));
        render.addArc({
          from: ml_r,
          to: tl_r,
          center: this.labels.l
        }, true);
        render.lineTo(intersect(tl_l, tl_r, ll_tr, ll_br));
        render.moveTo(intersect(this.labels.e, this.labels.f, ll_tr, ll_br));
        render.addArc(icc, true);
        render.addArc({
          from: new Point(lic.x, lic.y + lir),
          to: new Point(lic.x, lic.y - lir),
          center: lic
        }, true);
      }
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawC: function(id, variant, proportions) {
      var ik, inner_radius, lbr, lo_in, ltr, outline, radius, render, ro_in, tl, tr, ubr, utr;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      this.labels.g = this.labels.b.towards(this.labels.a, this.wide);
      this.labels.h = this.labels.d.towards(this.labels.c, this.wide);
      outline.drawLine(this.labels.g, this.labels.h);
      outline.drawLine(this.labels.c, this.labels.b);
      this.labels.i = midPoint(this.labels.e, this.labels.f);
      this.labels.k = this.labels.i.towards(this.labels.f, this.wide);
      radius = this.labels.i.distance(this.labels.e);
      outline.drawCircle(this.labels.i, this.labels.e);
      outline.drawCircle(this.labels.k, this.labels.f.towards(this.labels.e, -this.wide));
      tr = this.labels.f.towards(this.labels.e, this.wide / 2);
      tl = this.labels.d.towards(this.labels.c, this.wide / 2);
      outline.drawLine(tr, tl);
      ik = midPoint(this.labels.i, this.labels.k);
      inner_radius = radius - this.narrow;
      outline.drawCircle(ik, ik.towards(this.labels.e, inner_radius));
      render = new FillShape(sys.ctx);
      ubr = (vertCircle(this.labels.i, radius, tr.x)).lower;
      lbr = (vertCircle(this.labels.k, radius, tr.x)).lower;
      utr = (vertCircle(this.labels.k, radius, this.labels.g.x)).upper;
      ltr = (vertCircle(this.labels.i, radius, this.labels.g.x)).upper;
      render.moveTo(ubr);
      render.addArc({
        from: lbr,
        to: new Point(this.labels.k.x, this.labels.c.y),
        center: this.labels.k
      }, false);
      render.addArc({
        from: new Point(this.labels.i.x, this.labels.c.y),
        to: new Point(this.labels.i.x, this.labels.a.y),
        center: this.labels.i
      }, false);
      render.addArc({
        from: new Point(this.labels.k.x, this.labels.a.y),
        to: utr,
        center: this.labels.k
      }, false);
      render.lineTo(ltr);
      lo_in = intersectCircles(this.labels.i, radius, ik, inner_radius);
      render.addArc({
        from: ltr,
        to: lo_in.left,
        center: this.labels.i
      }, true);
      ro_in = intersectCircles(this.labels.k, radius, ik, inner_radius);
      render.addArc({
        from: lo_in.left,
        to: ro_in.right,
        center: ik
      }, true);
      render.addArc({
        from: ro_in.right,
        to: ro_in.left,
        center: this.labels.k
      }, true);
      render.addArc({
        from: ro_in.left,
        to: lo_in.right,
        center: ik
      }, true);
      render.addArc({
        from: lo_in.right,
        to: ubr,
        center: this.labels.i
      }, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawD: function(id, variant, proportions) {
      var bl_l, bl_r, innerRadius, isp, ll_bl, ll_br, ll_tl, ll_tr, lls, outline, render, tl_l, tl_r, tls, _is;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      this.labels.g = this.labels.g = midPoint(this.labels.a, this.labels.b);
      this.labels.h = this.labels.h = midPoint(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.g, this.labels.h);
      this.labels.i = this.labels.i = intersect(this.labels.e, this.labels.f, this.labels.g, this.labels.h);
      ll_bl = this.labels.c.towards(this.labels.d, this.serif);
      ll_br = ll_bl.towards(this.labels.d, this.wide);
      ll_tl = this.labels.a.towards(this.labels.b, this.serif);
      ll_tr = ll_tl.towards(this.labels.b, this.wide);
      outline.drawLine(ll_bl, ll_tl);
      outline.drawLine(ll_br, ll_tr);
      lls = outline.drawTouchingCircle(this.labels.c, ll_bl, ll_tl);
      tls = outline.drawTouchingCircle(ll_bl, ll_tl, this.labels.a);
      outline.drawCircle(this.labels.i, this.labels.f);
      this.labels.k = this.labels.k = this.labels.f.towards(this.labels.e, this.wide);
      tl_l = this.labels.a.towards(this.labels.c, this.narrow);
      tl_r = this.labels.g.towards(this.labels.h, this.narrow);
      outline.drawLine(tl_l, tl_r);
      bl_l = this.labels.c.towards(this.labels.a, this.narrow);
      bl_r = this.labels.h.towards(this.labels.g, this.narrow);
      outline.drawLine(bl_l, bl_r);
      innerRadius = tl_l.distance(this.labels.e);
      this.labels.l = this.labels.l = this.labels.k.towards(this.labels.e, innerRadius);
      outline.drawCircle(this.labels.l, this.labels.k);
      isp = bl_l.towards(bl_r, this.serif + this.wide + this.serif);
      _is = outline.drawTouchingCircle(ll_tr, intersect(ll_tr, ll_br, bl_l, bl_r), isp);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(lls, true);
      render.addArc(tls, true);
      render.addArc({
        from: this.labels.g,
        to: this.labels.h,
        center: this.labels.i
      }, false);
      render.lineTo(this.labels.c);
      render.moveTo(intersect(ll_tr, ll_br, tl_l, tl_r));
      render.addArc(_is, true);
      render.addArc({
        to: new Point(this.labels.l.x, tl_l.y),
        from: new Point(this.labels.l.x, bl_l.y),
        center: this.labels.l
      }, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawE: function(id, variant, proportions) {
      var bl_br, bl_l, bl_r, blls, blrs, bls, ll_bl, ll_br, ll_tl, ll_tr, ml_l, ml_lr, ml_r, ml_rl, ml_ru, mlls, mlus, outline, render, tl_l, tl_r, tl_tr, tl_trd, tlrs, tls, trs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      if (variant !== 'l') {
        this.labels.e = this.labels.e = midPoint(this.labels.a, this.labels.c);
        this.labels.f = this.labels.f = midPoint(this.labels.b, this.labels.d);
        outline.drawLine(this.labels.e, this.labels.f);
      }
      ll_tl = this.labels.a.towards(this.labels.b, this.serif);
      ll_tr = ll_tl.towards(this.labels.b, this.wide);
      ll_bl = this.labels.c.towards(this.labels.d, this.serif);
      ll_br = ll_bl.towards(this.labels.d, this.wide);
      outline.drawLine(ll_tl, ll_bl);
      outline.drawLine(ll_tr, ll_br);
      tls = outline.drawTouchingCircle(ll_bl, ll_tl, this.labels.a);
      bls = outline.drawTouchingCircle(this.labels.c, ll_bl, ll_tl);
      if (variant === 'l') {
        trs = outline.drawTouchingCircle(ll_tr.towards(this.labels.b, this.serif), ll_tr, ll_br);
      }
      tl_tr = this.labels.a.towards(this.labels.b, (6 - 1 / 3) * this.wide);
      tl_trd = new Point(tl_tr.x, this.labels.c.y);
      outline.drawLine(tl_tr, tl_trd);
      if (variant !== 'l') {
        tl_l = this.labels.a.towards(this.labels.c, this.narrow);
        tl_r = tl_tr.towards(tl_trd, this.narrow);
        outline.drawLine(tl_l, tl_r);
        tlrs = outline.drawTouchingCircle(tl_tr.towards(tl_trd, this.wide), tl_r, tl_l);
        ml_l = this.labels.e.towards(this.labels.a, this.narrow);
        ml_lr = this.labels.e.towards(this.labels.f, (5 - 1 / 3) * this.wide);
        ml_r = new Point(ml_lr.x, ml_l.y);
        outline.drawLine(ml_l, ml_r);
        ml_rl = ml_r.towards(ml_lr, this.wide + this.narrow / 2);
        ml_ru = ml_rl.towards(ml_r, 2 * this.wide);
        outline.drawLine(ml_ru, new Point(ml_r.x, this.labels.c.y));
        mlus = outline.drawTouchingCircle(ml_l, ml_r, ml_ru);
        mlls = outline.drawTouchingCircle(ml_rl, ml_lr, this.labels.e);
      }
      if (variant !== 'f') {
        bl_l = this.labels.c.towards(this.labels.a, this.narrow);
        bl_br = this.labels.c.towards(this.labels.d, (7 - 1 / 3) * this.wide);
        bl_r = new Point(bl_br.x, bl_l.y);
        outline.drawLine(bl_l, bl_r);
        blrs = outline.drawTouchingCircle(intersect(tl_tr, tl_trd, bl_l, bl_r), bl_r, this.labels.b);
        outline.drawLine(blrs.to, bl_br);
        blls = outline.drawTouchingCircle(ll_tr, intersect(ll_tr, ll_br, bl_l, bl_r), bl_l.towards(bl_r, this.serif + this.wide + (this.wide - this.narrow / 2)));
      } else {
        blls = outline.drawTouchingCircle(ll_tr, ll_br, ll_br.towards(this.labels.d, this.serif));
      }
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(bls, true);
      render.addArc(tls, true);
      if (variant !== 'l') {
        render.lineTo(tl_tr);
        render.addArc(tlrs, true);
        render.lineTo(intersect(tl_l, tl_r, ll_tr, ll_br));
        render.lineTo(intersect(ll_tr, ll_br, ml_l, ml_r));
        render.addArc(mlus, true);
        render.addArc(mlls, true);
        render.lineTo(intersect(ll_tr, ll_br, this.labels.e, this.labels.f));
      } else {
        render.addArc(trs, true);
      }
      render.addArc(blls, true);
      if (variant !== 'f') {
        render.addArc(blrs, true);
        render.lineTo(bl_br);
      }
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawG: function(id, variant, proportions) {
      var gk_v, icc, icl, icr, lo_in, lo_v, outerRadius, outline, render, rl_ll, rl_tl, rli, rlls, rlrs, ro_in, ro_v;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      this.labels.g = this.labels.b.towards(this.labels.a, this.wide);
      this.labels.h = this.labels.d.towards(this.labels.c, this.wide);
      outline.drawLine(this.labels.g, this.labels.h);
      outline.drawLine(this.labels.b, this.labels.c);
      this.labels.i = intersect(this.labels.b, this.labels.c, this.labels.e, this.labels.f);
      this.labels.k = this.labels.i.towards(this.labels.f, this.wide);
      outline.drawCircle(this.labels.i, this.labels.e);
      outline.drawCircle(this.labels.k, this.labels.e.towards(this.labels.f, this.wide));
      rl_ll = this.labels.h.towards(this.labels.c, this.wide);
      rli = intersect(this.labels.e, this.labels.f, this.labels.g, this.labels.h);
      rl_tl = rli.towards(this.labels.e, this.wide);
      outline.drawLine(rl_ll, rl_tl);
      rlls = outline.drawTouchingCircle(rl_ll, rl_tl, rl_tl.towards(this.labels.e, this.serif));
      rlrs = outline.drawTouchingCircle(this.labels.f, rli, this.labels.h);
      icc = midPoint(this.labels.i, this.labels.k);
      outerRadius = this.labels.i.distance(this.labels.e);
      icr = outerRadius - this.narrow;
      icl = icc.towards(this.labels.e, icr);
      outline.drawCircle(icc, icl);
      render = new FillShape(sys.ctx);
      gk_v = vertCircle(this.labels.k, outerRadius, this.labels.g.x);
      render.moveTo(gk_v.upper);
      lo_in = intersectCircles(this.labels.i, outerRadius, icc, icr);
      ro_in = intersectCircles(this.labels.k, outerRadius, icc, icr);
      lo_v = vertCircle(this.labels.i, outerRadius, this.labels.i.x);
      ro_v = vertCircle(this.labels.k, outerRadius, this.labels.k.x);
      render.addArc({
        from: (vertCircle(icc, icr, this.labels.g.x)).upper,
        to: ro_in.right,
        center: icc
      }, true);
      render.addArc({
        from: ro_in.right,
        to: ro_in.left,
        center: this.labels.k
      }, true);
      render.addArc({
        from: ro_in.left,
        to: (vertCircle(icc, icr, rl_ll.x)).lower,
        center: icc
      }, true);
      render.addArc(rlls, true);
      render.addArc(rlrs, true);
      render.addArc({
        from: gk_v.lower,
        to: ro_v.lower,
        center: this.labels.k
      }, false);
      render.addArc({
        from: lo_v.lower,
        to: lo_v.upper,
        center: this.labels.i
      }, false);
      render.addArc({
        from: ro_v.upper,
        to: gk_v.upper,
        center: this.labels.k
      }, false);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawH: function(id, variant, proportions) {
      var lbls, lbrs, ll_bl, ll_br, ll_brs, ll_tl, ll_tr, ll_trs, ltls, ltrs, ml_l, ml_r, outline, rbls, rbrs, render, rl_bl, rl_bls, rl_br, rl_tl, rl_tls, rl_tr, rtls, rtrs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      ll_bl = this.labels.c.towards(this.labels.d, this.serif);
      ll_br = ll_bl.towards(this.labels.d, this.wide);
      ll_brs = ll_br.towards(this.labels.d, this.serif);
      ll_tl = this.labels.a.towards(this.labels.b, this.serif);
      ll_tr = ll_tl.towards(this.labels.b, this.wide);
      ll_trs = ll_tr.towards(this.labels.b, this.serif);
      outline.drawLine(ll_bl, ll_tl);
      outline.drawLine(ll_br, ll_tr);
      lbls = outline.drawTouchingCircle(this.labels.c, ll_bl, ll_tl);
      ltls = outline.drawTouchingCircle(ll_bl, ll_tl, this.labels.a);
      ltrs = outline.drawTouchingCircle(ll_trs, ll_tr, ll_br);
      lbrs = outline.drawTouchingCircle(ll_tr, ll_br, ll_brs);
      rl_br = this.labels.d.towards(this.labels.c, this.serif);
      rl_bl = rl_br.towards(this.labels.c, this.wide);
      rl_bls = rl_bl.towards(this.labels.c, this.serif);
      rl_tr = this.labels.b.towards(this.labels.a, this.serif);
      rl_tl = rl_tr.towards(this.labels.a, this.wide);
      rl_tls = rl_tl.towards(this.labels.a, this.serif);
      outline.drawLine(rl_tr, rl_br);
      outline.drawLine(rl_tl, rl_bl);
      rbls = outline.drawTouchingCircle(rl_bls, rl_bl, rl_tl);
      rtls = outline.drawTouchingCircle(rl_bl, rl_tl, rl_tls);
      rtrs = outline.drawTouchingCircle(this.labels.b, rl_tr, rl_br);
      rbrs = outline.drawTouchingCircle(rl_tr, rl_br, this.labels.d);
      ml_l = this.labels.e.towards(this.labels.a, this.narrow);
      ml_r = this.labels.f.towards(this.labels.b, this.narrow);
      outline.drawLine(ml_l, ml_r);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(lbls, true);
      render.addArc(ltls, true);
      render.addArc(ltrs, true);
      render.lineTo(intersect(ml_l, ml_r, ll_tr, ll_br));
      render.lineTo(intersect(ml_l, ml_r, rl_tl, rl_bl));
      render.addArc(rtls, true);
      render.addArc(rtrs, true);
      render.addArc(rbrs, true);
      render.addArc(rbls, true);
      render.lineTo(intersect(this.labels.e, this.labels.f, rl_tl, rl_bl));
      render.lineTo(intersect(this.labels.e, this.labels.f, ll_tr, ll_br));
      render.addArc(lbrs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawI: function(id, variant, proportions) {
      var ab, bl, bll, bls, br, brr, brs, cd, outline, render, tl, tll, tls, tr, trr, trs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      ab = midPoint(this.labels.a, this.labels.b);
      cd = midPoint(this.labels.c, this.labels.d);
      bl = cd.towards(this.labels.c, this.wide / 2);
      bll = bl.towards(this.labels.c, this.serif);
      br = cd.towards(this.labels.d, this.wide / 2);
      brr = br.towards(this.labels.d, this.serif);
      tl = ab.towards(this.labels.a, this.wide / 2);
      tll = tl.towards(this.labels.a, this.serif);
      tr = ab.towards(this.labels.b, this.wide / 2);
      trr = tr.towards(this.labels.b, this.serif);
      outline.drawLine(tl, bl);
      outline.drawLine(tr, br);
      bls = outline.drawTouchingCircle(bll, bl, tl);
      tls = outline.drawTouchingCircle(bl, tl, tll);
      trs = outline.drawTouchingCircle(trr, tr, br);
      brs = outline.drawTouchingCircle(tr, br, brr);
      render = new FillShape(sys.ctx);
      render.moveTo(bll);
      render.addArc(bls, true);
      render.addArc(tls, true);
      render.addArc(trs, true);
      render.addArc(brs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawK: function(id, variant, proportions) {
      var ll_bl, ll_br, ll_brr, ll_tl, ll_tr, ll_trr, lls, lrs, outline, render, rll_ll, rll_lr, rll_lt, rll_ul, rll_ur, rll_ut, rul_l, rul_ll, rul_ls, rul_r, rul_rl, rul_rll, rul_rr, rul_rs, temp, uls, urs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      ll_bl = this.labels.c.towards(this.labels.d, this.serif);
      ll_br = ll_bl.towards(this.labels.d, this.wide);
      ll_brr = ll_br.towards(this.labels.d, this.serif);
      ll_tl = this.labels.a.towards(this.labels.b, this.serif);
      ll_tr = ll_tl.towards(this.labels.b, this.wide);
      ll_trr = ll_tr.towards(this.labels.b, this.serif);
      outline.drawLine(ll_tl, ll_bl);
      outline.drawLine(ll_tr, ll_br);
      lls = outline.drawTouchingCircle(this.labels.c, ll_bl, ll_tl);
      uls = outline.drawTouchingCircle(ll_bl, ll_tl, this.labels.a);
      urs = outline.drawTouchingCircle(ll_trr, ll_tr, ll_br);
      lrs = outline.drawTouchingCircle(ll_tr, ll_br, ll_brr);
      rul_l = intersect(this.labels.e, this.labels.f, ll_tr, ll_br);
      rul_r = intersect(this.labels.a, this.labels.b, rul_l, new Point(rul_l.x + this.labels.b.x - this.labels.c.x, rul_l.y + this.labels.b.y - this.labels.c.y));
      outline.drawLine(rul_l, rul_r);
      rul_rr = rul_r.towards(this.labels.b, this.serif);
      rul_rs = outline.drawTouchingCircle(rul_rr, rul_r, rul_l);
      temp = rul_l.towards(new Point(rul_l.x + this.labels.a.x - this.labels.d.x, rul_l.y + this.labels.a.y - this.labels.d.y), this.narrow);
      rul_ll = intersect(ll_tr, ll_br, temp, new Point(temp.x + this.labels.b.x - this.labels.c.x, temp.y + this.labels.b.y - this.labels.c.y));
      rul_rl = intersect(this.labels.a, this.labels.b, temp, rul_ll);
      outline.drawLine(rul_ll, rul_rl);
      rul_rll = rul_rl.towards(this.labels.a, this.serif);
      rul_ls = outline.drawTouchingCircle(rul_ll, rul_rl, rul_rll);
      rll_lr = intersect(this.labels.c, this.labels.d, rul_ll, new Point(rul_ll.x + this.labels.d.x - this.labels.a.x, rul_ll.y + this.labels.d.y - this.labels.a.y));
      rll_ll = intersect(rul_l, rul_r, rul_ll, rll_lr);
      outline.drawLine(rll_lr, rll_ll);
      rll_lt = outline.drawTouchingCircle(this.labels.d, rll_lr, rll_ll);
      this.labels.g = rll_lt.center;
      rll_ul = rll_ll.towards(rul_r, this.wide);
      rll_ur = intersect(this.labels.c, this.labels.d, rll_ul, new Point(rll_ul.x + this.labels.d.x - this.labels.a.x, rll_ul.y + this.labels.d.y - this.labels.a.y));
      outline.drawLine(rll_ur, rll_ul);
      rll_ut = outline.drawTouchingCircle(rll_ul, rll_ur, this.labels.d);
      this.labels.h = rll_ut.center;
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(lls, true);
      render.addArc(uls, true);
      render.addArc(urs, true);
      render.lineTo(rul_ll);
      render.addArc(rul_ls, true);
      render.addArc(rul_rs, true);
      render.lineTo(rll_ul);
      render.addArc(rll_ut, true);
      render.addArc(rll_lt, false);
      render.lineTo(rll_ll);
      render.lineTo(rul_l);
      render.addArc(lrs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawM: function(id, variant, proportions) {
      var dab, ll_bll, ll_br, ll_brr, ll_ls, ll_rs, ll_tl, ll_ts, ml_lt, ml_rb, mr_lb, mr_rt, outline, render, rl_bl, rl_bll, rl_brr, rl_ls, rl_rs, rl_tl, rl_tr, rl_ts;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      dab = this.labels.a.distance(this.labels.b);
      this.labels.f = this.labels.a.towards(this.labels.b, dab / 6);
      this.labels.g = this.labels.b.towards(this.labels.a, dab / 6);
      ll_tl = this.labels.f.towards(this.labels.a, this.narrow);
      outline.drawLine(ll_tl, this.labels.c);
      ll_br = this.labels.c.towards(this.labels.d, this.narrow);
      outline.drawLine(this.labels.f, ll_br);
      ll_bll = this.labels.c.towards(this.labels.d, -this.serif);
      ll_brr = ll_br.towards(this.labels.d, this.serif);
      ll_ls = outline.drawTouchingCircle(ll_bll, this.labels.c, ll_tl);
      ll_rs = outline.drawTouchingCircle(this.labels.f, ll_br, ll_brr);
      ll_ts = outline.drawTouchingCircle(this.labels.c, ll_tl, this.labels.a.towards(this.labels.b, -this.narrow));
      rl_tr = this.labels.g.towards(this.labels.b, this.narrow);
      outline.drawLine(rl_tr, this.labels.d);
      rl_tl = rl_tr.towards(this.labels.a, this.wide);
      rl_bl = this.labels.d.towards(this.labels.c, this.wide);
      outline.drawLine(rl_tl, rl_bl);
      rl_bll = rl_bl.towards(this.labels.c, this.serif);
      rl_ls = outline.drawTouchingCircle(rl_bll, rl_bl, rl_tl);
      rl_brr = this.labels.d.towards(this.labels.c, -this.serif);
      rl_rs = outline.drawTouchingCircle(rl_tr, this.labels.d, rl_brr);
      rl_ts = outline.drawTouchingCircle(this.labels.b.towards(this.labels.a, this.narrow), rl_tr, this.labels.d);
      this.labels.e = midPoint(this.labels.c, this.labels.d);
      ml_lt = this.labels.f.towards(this.labels.a, this.wide);
      outline.drawLine(ml_lt, this.labels.e);
      ml_rb = this.labels.e.towards(this.labels.d, this.wide);
      outline.drawLine(this.labels.f, ml_rb);
      mr_lb = this.labels.e.towards(this.labels.c, this.narrow);
      outline.drawLine(this.labels.g, mr_lb);
      mr_rt = this.labels.g.towards(this.labels.b, this.narrow);
      outline.drawLine(mr_rt, this.labels.e);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(ll_ls, true);
      render.addArc(ll_ts, true);
      render.lineTo(this.labels.f);
      render.lineTo(intersect(this.labels.f, ml_rb, mr_lb, this.labels.g));
      render.lineTo(this.labels.g);
      render.addArc(rl_ts, true);
      render.addArc(rl_rs, true);
      render.addArc(rl_ls, true);
      render.lineTo(intersect(rl_bl, rl_tl, this.labels.e, mr_rt));
      render.lineTo(this.labels.e);
      render.lineTo(intersect(this.labels.e, ml_lt, this.labels.f, ll_br));
      render.addArc(ll_rs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawN: function(id, variant, proportions) {
      var ll_bl, ll_br, ll_brr, ll_ls, ll_rs, ll_tl, ll_tr, ll_ts, outline, render, rl_bl, rl_ls, rl_rs, rl_tl, rl_tll, rl_tr;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      ll_bl = this.labels.c.towards(this.labels.d, this.serif);
      ll_br = ll_bl.towards(this.labels.d, this.narrow);
      ll_brr = ll_br.towards(this.labels.d, this.serif);
      ll_tl = this.labels.a.towards(this.labels.b, this.serif);
      ll_tr = ll_tl.towards(this.labels.b, this.narrow);
      outline.drawLine(ll_tl, ll_bl);
      outline.drawLine(ll_tr, ll_br);
      ll_ls = outline.drawTouchingCircle(this.labels.c, ll_bl, ll_tl);
      ll_ts = outline.drawTouchingCircle(ll_bl, ll_tl, this.labels.a.towards(this.labels.b, -this.serif / (Math.sqrt(2))));
      ll_rs = outline.drawTouchingCircle(ll_tr, ll_br, ll_brr);
      this.labels.e = this.labels.d.towards(this.labels.c, this.serif);
      outline.drawLine(this.labels.a, this.labels.e);
      outline.drawLine(ll_tr, this.labels.d);
      rl_bl = this.labels.e.towards(this.labels.c, this.narrow);
      rl_tr = this.labels.b.towards(this.labels.a, this.serif);
      rl_tl = rl_tr.towards(this.labels.a, this.narrow);
      rl_tll = rl_tl.towards(this.labels.a, this.serif);
      outline.drawLine(rl_tl, rl_bl);
      outline.drawLine(rl_tr, this.labels.e);
      rl_ls = outline.drawTouchingCircle(rl_bl, rl_tl, rl_tll);
      rl_rs = outline.drawTouchingCircle(this.labels.b, rl_tr, this.labels.e);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.addArc(ll_ls, true);
      render.addArc(ll_ts, true);
      render.lineTo(ll_tr);
      render.lineTo(intersect(ll_tr, this.labels.d, rl_bl, rl_tl));
      render.addArc(rl_ls, true);
      render.addArc(rl_rs, true);
      render.lineTo(this.labels.e);
      render.lineTo(intersect(this.labels.e, this.labels.a, ll_tr, ll_br));
      render.addArc(ll_rs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawO: function(id, variant, proportions) {
      var fgl, fgr, ib, il, ir, it, llor, ltc, ltci, ob, ol, ot, outline, radius, render, tailRadius, utc, utci, _or;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.c, this.labels.b);
      this.labels.e = midPoint(this.labels.c, this.labels.b);
      this.labels.f = this.labels.e.towards(this.labels.c, this.wide / 2);
      this.labels.g = this.labels.e.towards(this.labels.b, this.wide / 2);
      ol = new Point(this.labels.c.x, this.labels.f.y);
      ob = new Point(this.labels.f.x, this.labels.c.y);
      _or = new Point(this.labels.b.x, this.labels.g.y);
      ot = new Point(this.labels.g.x, this.labels.b.y);
      radius = this.labels.f.distance(ol);
      outline.drawCircle(this.labels.f, ob);
      outline.drawCircle(this.labels.g, ot);
      fgr = new Point(this.labels.f.y, this.labels.g.x);
      outline.drawCircle(fgr, ot);
      fgl = new Point(this.labels.f.x, this.labels.g.y);
      outline.drawCircle(fgl, ob);
      il = new Point(this.labels.g.x - radius, this.labels.g.y);
      it = new Point(this.labels.f.x, this.labels.f.y - radius);
      ib = new Point(this.labels.g.x, this.labels.g.y + radius);
      ir = new Point(this.labels.f.x + radius, this.labels.f.y);
      outline.drawCircle(fgl, il);
      outline.drawCircle(fgr, ir);
      if (variant === 'q') {
        outline.drawLine(this.labels.a, this.labels.d);
        tailRadius = this.labels.c.distance(this.labels.d);
        outline.drawLine(this.labels.d, this.labels.d.towards(this.labels.c, -tailRadius));
        this.labels.h = new Point((this.labels.d.towards(this.labels.c, -3 * tailRadius / 4)).x, this.labels.d.y + 0.01);
        utc = (intersectCircles(this.labels.d, tailRadius, this.labels.h, tailRadius)).left;
        outline.drawLine(this.labels.h, utc);
        outline.drawLine(this.labels.d, utc);
        outline.drawCircle(utc, this.labels.d);
        llor = fgl.distance(_or);
        utci = (intersectCircles(utc, tailRadius, fgl, llor)).left;
        outline.drawCircle(utci, new Point(utci.x, utci.y + this.wide));
        ltci = (intersectCircles(utci, this.wide, fgl, llor)).left;
        ltc = (intersectCircles(ltci, tailRadius, this.labels.h, tailRadius)).left;
        outline.drawLine(ltci, ltc);
        outline.drawLine(this.labels.h, ltc);
        outline.drawCircle(ltc, this.labels.h);
      }
      render = new FillShape(sys.ctx);
      render.moveTo(ob);
      render.addArc({
        from: ob,
        to: ol,
        center: this.labels.f
      }, false);
      render.addArc({
        from: ol,
        to: ot,
        center: fgr
      }, false);
      render.addArc({
        from: ot,
        to: _or,
        center: this.labels.g
      }, false);
      if (variant !== 'q') {
        render.addArc({
          from: _or,
          to: ob,
          center: fgl
        }, false);
      } else {
        render.addArc({
          from: _or,
          to: utci,
          center: fgl
        }, false);
        render.addArc({
          from: utci,
          to: this.labels.h,
          center: utc
        }, true);
        render.addArc({
          from: this.labels.h,
          to: ltci,
          center: ltc
        }, false);
        render.addArc({
          from: ltci,
          to: ob,
          center: fgl
        }, false);
      }
      render.moveTo(ib);
      render.addArc({
        from: ib,
        to: ir,
        center: fgr
      }, true);
      render.addArc({
        from: ir,
        to: it,
        center: this.labels.f
      }, true);
      render.addArc({
        from: it,
        to: il,
        center: fgl
      }, true);
      render.addArc({
        from: il,
        to: ib,
        center: this.labels.g
      }, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawS: function(id, variant, proportions) {
      var angle, bic, bir, boc, bor, hyp, lt, lti, ltu, ltx, outline, render, rtl, rtu, tic, toc;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      this.labels.g = midPoint(this.labels.a, this.labels.b);
      this.labels.h = midPoint(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.g, this.labels.h);
      this.labels.m = intersect(this.labels.e, this.labels.f, this.labels.g, this.labels.h);
      this.labels.i = this.labels.g.towards(this.labels.h, this.narrow);
      this.labels.k = this.labels.h.towards(this.labels.g, this.narrow);
      this.labels.l = this.labels.m.towards(this.labels.h, this.wide / 3);
      this.labels.n = this.labels.m.towards(this.labels.g, 2 * this.wide / 3);
      toc = midPoint(this.labels.g, this.labels.l);
      outline.drawCircle(toc, this.labels.g);
      tic = midPoint(this.labels.i, this.labels.n);
      outline.drawCircle(tic, this.labels.i);
      boc = midPoint(this.labels.n, this.labels.h);
      outline.drawCircle(boc, this.labels.h);
      bic = midPoint(this.labels.l, this.labels.k);
      outline.drawCircle(bic, this.labels.k);
      rtl = new Point(tic.x + (tic.distance(this.labels.i)), tic.y);
      outline.drawCircle(rtl, rtl.towards(tic, 4 * this.wide / 3));
      rtu = (intersectCircles(rtl, 4 * this.wide / 3, toc, toc.distance(this.labels.g))).left;
      outline.drawLine(rtl, rtu);
      bir = bic.distance(this.labels.l);
      bor = boc.distance(this.labels.n);
      ltx = boc.x - (bir + bor) / 2;
      lt = vertCircle(boc, bor, ltx);
      outline.drawLine(lt.lower, lt.upper);
      ltu = new Point(lt.lower.x, boc.y);
      outline.drawLine(ltu, boc);
      hyp = ltu.distance(bic);
      angle = (Math.acos(bir / hyp)) - (Math.acos(((bir + bor) / 2) / hyp));
      lti = new Point(bic.x - (Math.cos(angle)) * bir, bic.y + (Math.sin(angle)) * bir);
      outline.drawLine(lti, ltu);
      render = new FillShape(sys.ctx);
      render.moveTo(ltu);
      render.addArc({
        from: lti,
        to: this.labels.l,
        center: bic
      }, true);
      render.addArc({
        from: this.labels.l,
        to: rtu,
        center: toc
      }, false);
      render.addArc({
        from: rtl,
        to: this.labels.n,
        center: tic
      }, true);
      render.addArc({
        from: this.labels.n,
        to: lt.lower,
        center: boc
      }, false);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawT: function(id, variant, proportions) {
      var bls, brs, l_bl, l_bll, l_br, l_brr, l_tl, l_tr, lib, lic, lilb, lir, lob, loc, lor, ltl, ltu, outline, render, tl_l, tl_ll, tl_lu, tl_r, tl_rl, tl_ru, tlls, tlus, trls, trus;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      l_bl = (midPoint(this.labels.c, this.labels.d)).towards(this.labels.c, this.wide / 2);
      l_br = l_bl.towards(this.labels.d, this.wide);
      if (variant !== 'j') {
        l_bll = l_bl.towards(this.labels.c, this.serif);
        l_brr = l_br.towards(this.labels.d, this.serif);
      }
      l_tl = (midPoint(this.labels.a, this.labels.b)).towards(this.labels.a, this.wide / 2);
      l_tr = l_tl.towards(this.labels.b, this.wide);
      this.labels.e = this.labels.e = this.labels.a.towards(this.labels.b, this.wide);
      this.labels.f = this.labels.f = this.labels.b.towards(this.labels.a, this.wide);
      outline.drawLine(l_tl, l_bl);
      outline.drawLine(l_tr, l_br);
      if (variant !== 'j') {
        bls = outline.drawTouchingCircle(l_bll, l_bl, l_tl);
        brs = outline.drawTouchingCircle(l_tr, l_br, l_brr);
      } else {
        lob = midPoint(this.labels.c, l_br);
        lor = lob.distance(this.labels.c);
        loc = new Point(this.labels.c.x + lor, this.labels.c.y - lor);
        outline.drawCircle(loc, lob);
        lilb = new Point(this.labels.e.x - this.narrow / 2, this.labels.c.y);
        lib = midPoint(lilb, l_bl);
        lir = lib.distance(l_bl);
        lic = new Point(lib.x, this.labels.c.y - lir - this.narrow);
        outline.drawCircle(lic, new Point(lib.x, lib.y - this.narrow));
        outline.drawLine(this.labels.e, new Point(this.labels.e.x, this.labels.c.y));
        ltu = (vertCircle(lic, lir, this.labels.e.x)).lower;
        ltl = (vertCircle(loc, lor, this.labels.e.x)).lower;
      }
      tl_l = this.labels.a.towards(this.labels.c, this.narrow);
      tl_r = this.labels.b.towards(this.labels.d, this.narrow);
      outline.drawLine(tl_l, tl_r);
      tl_ll = new Point(this.labels.e.x - 3 * this.narrow, this.labels.e.y + 2 * this.narrow);
      tl_lu = new Point(this.labels.e.x + this.narrow, this.labels.e.y - this.narrow);
      outline.drawLine(tl_ll, tl_lu);
      tl_rl = new Point(this.labels.f.x - 2 * this.narrow, this.labels.e.y + 2 * this.narrow);
      tl_ru = new Point(this.labels.f.x + 2 * this.narrow, this.labels.e.y - this.narrow);
      outline.drawLine(tl_rl, tl_ru);
      tlls = outline.drawTouchingCircle(tl_r, intersect(tl_l, tl_r, tl_ll, tl_lu), tl_ll);
      tlus = outline.drawTouchingCircle(tl_lu, intersect(this.labels.a, this.labels.b, tl_ll, tl_lu), this.labels.b);
      trus = outline.drawTouchingCircle(this.labels.a, intersect(this.labels.a, this.labels.b, tl_rl, tl_ru), tl_ru);
      trls = outline.drawTouchingCircle(tl_rl, intersect(tl_l, tl_r, tl_rl, tl_ru), tl_l);
      render = new FillShape(sys.ctx);
      if (variant !== 'j') {
        render.moveTo(bls.from);
        render.addArc(bls, true);
      } else {
        render.moveTo(ltl);
        render.addArc({
          from: ltu,
          to: new Point(l_bl.x, lic.y),
          center: lic
        }, true);
      }
      render.lineTo(intersect(l_bl, l_tl, tl_l, tl_r));
      render.addArc(tlls, true);
      render.addArc(tlus, true);
      render.addArc(trus, true);
      render.addArc(trls, true);
      render.lineTo(intersect(l_br, l_tr, tl_l, tl_r));
      if (variant !== 'j') {
        render.addArc(brs, true);
      } else {
        render.addArc({
          from: new Point(l_br.x, loc.y),
          to: ltl,
          center: loc
        }, false);
      }
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawU: function(id, variant, proportions) {
      var lic, lir, ll_br, ll_tr, ll_trr, loc, lor, outline, render, rl_bl, rl_tl, rl_tll, rlls, rlrs, tlls, tlrs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.c, this.labels.d);
      this.labels.f = this.labels.a.towards(this.labels.b, this.serif);
      this.labels.g = this.labels.c.towards(this.labels.d, this.serif);
      outline.drawLine(this.labels.f, this.labels.g);
      this.labels.h = this.labels.b.towards(this.labels.a, this.serif);
      this.labels.i = this.labels.d.towards(this.labels.c, this.serif);
      outline.drawLine(this.labels.h, this.labels.i);
      ll_tr = this.labels.f.towards(this.labels.b, this.wide);
      ll_trr = ll_tr.towards(this.labels.b, this.serif);
      ll_br = this.labels.g.towards(this.labels.d, this.wide);
      outline.drawLine(ll_tr, ll_br);
      tlls = outline.drawTouchingCircle(this.labels.g, this.labels.f, this.labels.a);
      tlrs = outline.drawTouchingCircle(ll_trr, ll_tr, ll_br);
      rl_tl = this.labels.h.towards(this.labels.a, this.wide);
      rl_tll = rl_tl.towards(this.labels.a, this.serif);
      rl_bl = this.labels.i.towards(this.labels.c, this.wide);
      outline.drawLine(rl_tl, rl_bl);
      rlls = outline.drawTouchingCircle(rl_bl, rl_tl, rl_tll);
      rlrs = outline.drawTouchingCircle(this.labels.b, this.labels.h, this.labels.i);
      lor = this.labels.e.distance(this.labels.g);
      loc = new Point(this.labels.e.x, this.labels.e.y - lor);
      outline.drawCircle(loc, this.labels.e);
      lir = this.labels.e.distance(ll_br);
      lic = new Point(this.labels.e.x, this.labels.e.y - lir - this.narrow);
      outline.drawCircle(lic, new Point(this.labels.e.x, this.labels.e.y - this.narrow));
      render = new FillShape(sys.ctx);
      render.moveTo(tlls.from);
      render.addArc(tlls, true);
      render.addArc(tlrs, true);
      render.addArc({
        from: new Point(ll_br.x, lic.y),
        to: new Point(rl_bl.x, lic.y),
        center: lic
      }, true);
      render.addArc(rlls, true);
      render.addArc(rlrs, true);
      render.addArc({
        from: new Point(this.labels.h.x, loc.y),
        to: new Point(this.labels.f.x, loc.y),
        center: loc
      }, false);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawV: function(id, variant, proportions) {
      var ll_br, ll_tr, ll_trr, llls, llrs, outline, render, rl_bl, rl_tl, rl_tll, rlls, rlrs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.c, this.labels.d);
      this.labels.f = this.labels.a.towards(this.labels.b, this.serif);
      this.labels.g = this.labels.b.towards(this.labels.a, this.serif);
      ll_tr = this.labels.f.towards(this.labels.b, this.wide);
      ll_trr = ll_tr.towards(this.labels.b, this.serif);
      ll_br = this.labels.e.towards(this.labels.d, this.wide);
      outline.drawLine(this.labels.f, this.labels.e);
      outline.drawLine(ll_tr, ll_br);
      llls = outline.drawTouchingCircle(this.labels.e, this.labels.f, this.labels.a);
      llrs = outline.drawTouchingCircle(ll_trr, ll_tr, ll_br);
      rl_tl = this.labels.g.towards(this.labels.a, this.narrow);
      rl_tll = rl_tl.towards(this.labels.a, this.serif);
      rl_bl = this.labels.e.towards(this.labels.c, this.narrow);
      outline.drawLine(rl_tl, rl_bl);
      outline.drawLine(this.labels.g, this.labels.e);
      rlls = outline.drawTouchingCircle(rl_bl, rl_tl, rl_tll);
      rlrs = outline.drawTouchingCircle(this.labels.b, this.labels.g, this.labels.e);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.e);
      render.addArc(llls, true);
      render.addArc(llrs, true);
      render.lineTo(intersect(ll_tr, ll_br, rl_tl, rl_bl));
      render.addArc(rlls, true);
      render.addArc(rlrs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawW: function(id, variant, proportions) {
      var a_l, a_r, a_rr, als, ars, b_l, b_ll, b_r, bls, brs, e_l, e_r, f_l, f_r, fg, g_l, g_r, outline, render;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.b);
      fg = midPoint(this.labels.c, this.labels.d);
      this.labels.f = midPoint(this.labels.c, fg);
      this.labels.g = midPoint(fg, this.labels.d);
      f_l = this.labels.f.towards(this.labels.c, this.narrow);
      f_r = this.labels.f.towards(this.labels.d, this.wide);
      g_l = this.labels.g.towards(this.labels.c, this.narrow);
      g_r = this.labels.g.towards(this.labels.d, this.wide);
      a_l = this.labels.a.towards(this.labels.b, -this.serif);
      a_r = this.labels.a.towards(this.labels.b, this.wide);
      a_rr = a_r.towards(this.labels.b, this.serif);
      outline.drawLine(this.labels.a, this.labels.f);
      outline.drawLine(a_r, f_r);
      e_l = this.labels.e.towards(this.labels.a, this.wide);
      e_r = this.labels.e.towards(this.labels.b, this.narrow);
      outline.drawLine(this.labels.e, f_l);
      outline.drawLine(e_r, this.labels.f);
      als = outline.drawTouchingCircle(this.labels.f, this.labels.a, a_l);
      ars = outline.drawTouchingCircle(a_rr, a_r, f_r);
      outline.drawLine(e_l, this.labels.g);
      outline.drawLine(this.labels.e, g_r);
      b_l = this.labels.b.towards(this.labels.a, this.narrow);
      b_ll = b_l.towards(this.labels.a, this.serif);
      b_r = this.labels.b.towards(this.labels.a, -this.serif);
      outline.drawLine(b_l, g_l);
      outline.drawLine(this.labels.b, this.labels.g);
      bls = outline.drawTouchingCircle(g_l, b_l, b_ll);
      brs = outline.drawTouchingCircle(b_r, this.labels.b, this.labels.g);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.f);
      render.addArc(als, true);
      render.addArc(ars, true);
      render.lineTo(intersect(a_r, f_r, f_l, this.labels.e));
      render.lineTo(this.labels.e);
      render.lineTo(intersect(this.labels.e, g_r, g_l, b_l));
      render.addArc(bls, true);
      render.addArc(brs, true);
      render.lineTo(this.labels.g);
      render.lineTo(intersect(this.labels.g, e_l, e_r, this.labels.f));
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawX: function(id, variant, proportions) {
      var bl_r, bl_rr, blls, blrs, br_l, br_ll, brls, brrs, outline, render, tl_r, tl_rr, tlls, tlrs, tr_l, tr_ll, trls, trrs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.f = this.labels.a.towards(this.labels.b, this.serif);
      this.labels.g = this.labels.c.towards(this.labels.d, this.serif);
      outline.drawLine(this.labels.f, this.labels.g);
      this.labels.h = this.labels.b.towards(this.labels.a, this.serif);
      this.labels.i = this.labels.d.towards(this.labels.c, this.serif);
      outline.drawLine(this.labels.h, this.labels.i);
      tl_r = this.labels.f.towards(this.labels.b, this.wide);
      tl_rr = tl_r.towards(this.labels.b, this.serif);
      bl_r = this.labels.g.towards(this.labels.d, this.narrow);
      bl_rr = bl_r.towards(this.labels.d, this.serif);
      tr_l = this.labels.h.towards(this.labels.a, this.narrow);
      tr_ll = tr_l.towards(this.labels.a, this.serif);
      br_l = this.labels.i.towards(this.labels.c, this.wide);
      br_ll = br_l.towards(this.labels.c, this.serif);
      outline.drawLine(this.labels.f, br_l);
      outline.drawLine(tl_r, this.labels.i);
      outline.drawLine(tr_l, this.labels.g);
      outline.drawLine(this.labels.h, bl_r);
      tlls = outline.drawTouchingCircle(br_l, this.labels.f, this.labels.a);
      tlrs = outline.drawTouchingCircle(tl_rr, tl_r, this.labels.i);
      trls = outline.drawTouchingCircle(this.labels.g, tr_l, tr_ll);
      trrs = outline.drawTouchingCircle(this.labels.b, this.labels.h, bl_r);
      blls = outline.drawTouchingCircle(this.labels.c, this.labels.g, tr_l);
      blrs = outline.drawTouchingCircle(this.labels.h, bl_r, bl_rr);
      brrs = outline.drawTouchingCircle(tl_r, this.labels.i, this.labels.d);
      brls = outline.drawTouchingCircle(br_ll, br_l, this.labels.f);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.g);
      render.addArc(blls, true);
      render.lineTo(intersect(this.labels.g, tr_l, this.labels.f, br_l));
      render.addArc(tlls, true);
      render.addArc(tlrs, true);
      render.lineTo(intersect(tl_r, this.labels.i, this.labels.g, tr_l));
      render.addArc(trls, true);
      render.addArc(trrs, true);
      render.lineTo(intersect(this.labels.h, bl_r, this.labels.i, tl_r));
      render.addArc(brrs, true);
      render.addArc(brls, true);
      render.lineTo(intersect(br_l, this.labels.f, this.labels.h, bl_r));
      render.addArc(blrs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawY: function(id, variant, proportions) {
      var bls, brs, ll_bl, ll_bll, ll_br, ll_brr, ll_tl, ll_tr, outline, render, tl_l, tl_r, tl_rr, tlls, tlm, tlrs, tr_l, tr_ll, tr_r, trls, trrs;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = midPoint(this.labels.a, this.labels.c);
      this.labels.f = midPoint(this.labels.b, this.labels.d);
      outline.drawLine(this.labels.e, this.labels.f);
      ll_bl = (midPoint(this.labels.c, this.labels.d)).towards(this.labels.c, this.wide / 2);
      ll_bll = ll_bl.towards(this.labels.c, this.serif);
      ll_br = ll_bl.towards(this.labels.d, this.wide);
      ll_brr = ll_br.towards(this.labels.d, this.serif);
      ll_tl = (midPoint(this.labels.e, this.labels.f)).towards(this.labels.e, this.wide / 2);
      ll_tr = ll_tl.towards(this.labels.f, this.wide);
      outline.drawLine(ll_tl, ll_bl);
      outline.drawLine(ll_tr, ll_br);
      bls = outline.drawTouchingCircle(ll_bll, ll_bl, ll_tl);
      brs = outline.drawTouchingCircle(ll_tr, ll_br, ll_brr);
      tlm = ll_tl.towards(ll_tr, 2 * this.wide / 3);
      tl_l = this.labels.a.towards(this.labels.b, this.serif);
      tl_r = tl_l.towards(this.labels.b, 2 * this.wide / 3);
      tl_rr = tl_r.towards(this.labels.b, this.serif);
      tr_r = this.labels.b.towards(this.labels.a, this.serif);
      tr_l = tr_r.towards(this.labels.a, this.wide / 3);
      tr_ll = tr_l.towards(this.labels.a, this.serif);
      outline.drawLine(tl_l, ll_tl);
      outline.drawLine(tl_r, tlm);
      outline.drawLine(tr_l, tlm);
      outline.drawLine(tr_r, ll_tr);
      tlls = outline.drawTouchingCircle(ll_tl, tl_l, this.labels.a);
      tlrs = outline.drawTouchingCircle(tl_rr, tl_r, tlm);
      trls = outline.drawTouchingCircle(tlm, tr_l, tr_ll);
      trrs = outline.drawTouchingCircle(this.labels.b, tr_r, ll_tr);
      render = new FillShape(sys.ctx);
      render.moveTo(midPoint(this.labels.c, this.labels.d));
      render.addArc(bls, true);
      render.lineTo(ll_tl);
      render.addArc(tlls, true);
      render.addArc(tlrs, true);
      render.lineTo(tlm);
      render.addArc(trls, true);
      render.addArc(trrs, true);
      render.lineTo(ll_tr);
      render.addArc(brs, true);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    drawZ: function(id, variant, proportions) {
      var bl_l, bl_r, brs, ml_br, ml_tl, outline, render, tl_l, tl_r, tls;
      outline = new OutlineDrawer(sys.ctx);
      outline.drawLine(this.labels.a, this.labels.b);
      outline.drawLine(this.labels.c, this.labels.d);
      outline.drawLine(this.labels.a, this.labels.c);
      outline.drawLine(this.labels.b, this.labels.d);
      this.labels.e = this.labels.a.towards(this.labels.c, this.serif);
      this.labels.f = this.labels.a.towards(this.labels.b, this.serif);
      outline.drawLine(this.labels.e, this.labels.f);
      this.labels.g = this.labels.d.towards(this.labels.c, this.serif);
      this.labels.h = this.labels.d.towards(this.labels.b, this.serif);
      outline.drawLine(this.labels.g, this.labels.h);
      tl_l = this.labels.a.towards(this.labels.c, this.narrow);
      tl_r = this.labels.b.towards(this.labels.d, this.narrow);
      outline.drawLine(tl_l, tl_r);
      tls = outline.drawTouchingCircle(tl_r, intersect(tl_l, tl_r, this.labels.e, this.labels.f), this.labels.e);
      bl_l = this.labels.c.towards(this.labels.a, this.narrow);
      bl_r = this.labels.d.towards(this.labels.b, this.narrow);
      outline.drawLine(bl_l, bl_r);
      brs = outline.drawTouchingCircle(bl_l, intersect(bl_l, bl_r, this.labels.g, this.labels.h), this.labels.h);
      ml_br = this.labels.c.towards(this.labels.d, this.wide * 1.25);
      ml_tl = this.labels.b.towards(this.labels.a, this.wide * 1.25);
      outline.drawLine(ml_tl, this.labels.c);
      outline.drawLine(this.labels.b, ml_br);
      render = new FillShape(sys.ctx);
      render.moveTo(this.labels.c);
      render.lineTo(intersect(this.labels.c, ml_tl, tl_l, tl_r));
      render.addArc(tls, true);
      render.lineTo(this.labels.f);
      render.lineTo(this.labels.b);
      render.lineTo(intersect(this.labels.b, ml_br, bl_l, bl_r));
      render.addArc(brs, true);
      render.lineTo(this.labels.g);
      render.closeAndFill();
      outline.labelPoints(this.labels);
    },
    lookupGlyphFunction: function(letter) {
      switch (letter) {
        case 'a':
          return 'drawA';
        case 'b':
          return 'drawB';
        case 'c':
          return 'drawC';
        case 'd':
          return 'drawD';
        case 'e':
          return 'drawE';
        case 'f':
          return 'drawE';
        case 'g':
          return 'drawG';
        case 'h':
          return 'drawH';
        case 'i':
          return 'drawI';
        case 'j':
          return 'drawT';
        case 'k':
          return 'drawK';
        case 'l':
          return 'drawE';
        case 'm':
          return 'drawM';
        case 'n':
          return 'drawN';
        case 'o':
          return 'drawO';
        case 'p':
          return 'drawB';
        case 'q':
          return 'drawO';
        case 'r':
          return 'drawB';
        case 's':
          return 'drawS';
        case 't':
          return 'drawT';
        case 'u':
          return 'drawU';
        case 'v':
          return 'drawV';
        case 'w':
          return 'drawW';
        case 'x':
          return 'drawX';
        case 'y':
          return 'drawY';
        case 'z':
          return 'drawZ';
        default:
          return void 0;
      }
    },
    getGlyphFunction: function(letter) {
      var fname, t,
        _this = this;
      t = this;
      fname = this.lookupGlyphFunction(letter);
      if (fname !== void 0) {
        return function(id, variant, prop) {
          _this.initializeGlyph(id, prop);
          return _this[fname](id, variant, prop);
        };
      } else {
        return fname;
      }
    },
    drawLetter: function(id, letter, proportions) {
      var f;
      letter = letter.toLowerCase();
      f = this.getGlyphFunction(letter);
      if (f !== void 0) {
        f(id, letter, proportions);
      } else {
        console.log('Cannot find rendering functions for', letter);
      }
    }
  };

  proportions = {
    aspect: 1,
    broad_stem: 0.111,
    narrow_stem: 0.33,
    serif: 0.111,
    readFromDocument: function() {
      var broad;
      broad = this.broad_stem = ((document.getElementById('broadProp')).value | 0) / 1000.0;
      this.narrow_stem = ((document.getElementById('narrowProp')).value | 0) / 100.0;
      this.serif = ((document.getElementById('serifProp')).value | 0) / 1000.0;
    }
  };

  getLetterShape = function(letter, proportions) {
    var f, oldOutline;
    letter = letter.toLowerCase();
    f = GlyphFunctions.getGlyphFunction(letter);
    if (f !== void 0) {
      oldOutline = sys.showOutlines;
      sys.showOutlines = false;
      f(void 0, letter, proportions);
      sys.showOutlines = oldOutline;
      return [sys.ctx.path, sys.ctx.lx, sys.ctx.rx, sys.ctx.leftLimits, sys.ctx.rightLimits];
    } else {
      return '';
    }
  };

  drawProofs = function() {
    GlyphFunctions.drawLetter('glyph-A', 'A', proportions);
    GlyphFunctions.drawLetter('glyph-B', 'B', proportions);
    GlyphFunctions.drawLetter('glyph-C', 'C', proportions);
    GlyphFunctions.drawLetter('glyph-D', 'D', proportions);
    GlyphFunctions.drawLetter('glyph-E', 'E', proportions);
    GlyphFunctions.drawLetter('glyph-F', 'F', proportions);
    GlyphFunctions.drawLetter('glyph-G', 'G', proportions);
    GlyphFunctions.drawLetter('glyph-H', 'H', proportions);
    GlyphFunctions.drawLetter('glyph-I', 'I', proportions);
    GlyphFunctions.drawLetter('glyph-J', 'J', proportions);
    GlyphFunctions.drawLetter('glyph-K', 'K', proportions);
    GlyphFunctions.drawLetter('glyph-L', 'L', proportions);
    GlyphFunctions.drawLetter('glyph-M', 'M', proportions);
    GlyphFunctions.drawLetter('glyph-N', 'N', proportions);
    GlyphFunctions.drawLetter('glyph-O', 'O', proportions);
    GlyphFunctions.drawLetter('glyph-P', 'P', proportions);
    GlyphFunctions.drawLetter('glyph-Q', 'Q', proportions);
    GlyphFunctions.drawLetter('glyph-R', 'R', proportions);
    GlyphFunctions.drawLetter('glyph-S', 'S', proportions);
    GlyphFunctions.drawLetter('glyph-T', 'T', proportions);
    GlyphFunctions.drawLetter('glyph-U', 'U', proportions);
    GlyphFunctions.drawLetter('glyph-V', 'V', proportions);
    GlyphFunctions.drawLetter('glyph-W', 'W', proportions);
    GlyphFunctions.drawLetter('glyph-X', 'X', proportions);
    GlyphFunctions.drawLetter('glyph-Y', 'Y', proportions);
    GlyphFunctions.drawLetter('glyph-Z', 'Z', proportions);
  };

  drawSampleText = function() {
    var i, id, k, kernOffset, kleft, left, leftLim, letter, offset, path, rightLim, shape, text, width, _i, _j, _k, _ref, _ref1;
    text = (document.getElementById('sampleText')).value;
    offset = 0;
    kernOffset = [0, 0, 0, 0, 0];
    for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      letter = text[i];
      id = 'demo' + i;
      path = document.getElementById(id);
      if (path === void 0) {
        continue;
      }
      shape = getLetterShape(letter, proportions);
      if (shape === '') {
        console.log('Cannot get letter shape for:', letter);
        continue;
      }
      left = shape[1];
      width = shape[2] - shape[1];
      if (width > 1) {
        width = 1;
      }
      leftLim = shape[3];
      rightLim = shape[4];
      kleft = 100000;
      for (k = _j = 0; _j < 5; k = ++_j) {
        kleft = Math.min(kleft, leftLim[k] - kernOffset[k]);
        kernOffset[k] = rightLim[k] - 1;
      }
      offset -= kleft;
      path.setAttribute('d', shape[0]);
      path.setAttribute('transform', 'translate(' + offset + ')');
      offset += 1.1;
    }
    if (text.length < 10) {
      for (i = _k = _ref1 = text.length; _ref1 <= 10 ? _k < 10 : _k > 10; i = _ref1 <= 10 ? ++_k : --_k) {
        path = document.getElementById('demo' + i);
        path.setAttribute('d', 'M 0 0');
      }
    }
  };

  onEvent = function(id, event, callback) {
    var element;
    element = document.getElementById(id);
    if (element.addEventListener != null) {
      element.addEventListener(event, callback, false);
    } else {
      element.attachEvent('on' + event, callback);
    }
  };

  bindValueToText = function(from, to) {
    var source, target;
    source = document.getElementById(from);
    target = document.getElementById(to);
    onEvent(from, 'change', function() {
      return target.innerHTML = source.value;
    });
    return onEvent(from, 'input', function() {
      return target.innerHTML = source.value;
    });
  };

  onload = function() {
    changeProportions();
    drawProofs();
    drawSampleText();
    bindValueToText('broadProp', 'broadPropValue');
    bindValueToText('serifProp', 'serifPropValue');
    bindValueToText('narrowProp', 'narrowPropValue');
    onEvent('broadProp', 'change', changeProportions);
    onEvent('serifProp', 'change', changeProportions);
    onEvent('narrowProp', 'change', changeProportions);
    onEvent('broadProp', 'input', changeProportions);
    onEvent('serifProp', 'input', changeProportions);
    onEvent('narrowProp', 'input', changeProportions);
    onEvent('showProofs', 'change', showProofsChanged);
    onEvent('fillGlyph', 'change', redrawProofs);
    onEvent('strokeGlyph', 'change', redrawProofs);
    onEvent('overshoot', 'change', redrawProofs);
    onEvent('showOutlines', 'change', redrawProofs);
    onEvent('glyphColor', 'change', redrawProofs);
    onEvent('proofSize', 'change', changeProofSize);
    onEvent('proofSize', 'input', changeProofSize);
    onEvent('showSample', 'change', showSampleChanged);
    onEvent('sampleText', 'change', changeSampleText);
  };

  onload();

}).call(this);

/*
//@ sourceMappingURL=durer.map
*/
